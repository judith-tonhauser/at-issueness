# turn all lower triangle cells black
tmp = tableData %>%
mutate('be right' = case_when('be right' = TRUE ~ "\\cellcolor{black}"),
'confirm' = case_when('confirm' = TRUE & expression != 'be right' ~ "\\cellcolor{black}"))
tmp
#view(tableData)
tableData
# turn all lower triangle cells black
tmp = tableData %>%
mutate('be right' = case_when('be right' = TRUE ~ "\\cellcolor{black}"),
'confirm' = case_when('confirm' = TRUE & expression != 'be right' ~ "\\cellcolor{black}"),
TRUE ~ 'confirm')
# turn all lower triangle cells black
tmp = tableData %>%
mutate('be right' = case_when('be right' = TRUE ~ "\\cellcolor{black}"),
confirm = case_when(confirm = TRUE & expression != 'be right' ~ "\\cellcolor{black}"),
TRUE ~ as.character(confirm))
# turn all lower triangle cells black
tmp = tableData %>%
mutate('be right' = case_when('be right' = TRUE ~ "\\cellcolor{black}"),
confirm = case_when(confirm = TRUE & expression != 'be right' ~ "\\cellcolor{black}"),
as.default(as.character(confirm)))
# turn all lower triangle cells black
tmp = tableData %>%
mutate('be right' = case_when('be right' = TRUE ~ "\\cellcolor{black}"),
confirm = case_when(confirm = TRUE & expression != 'be right' ~ "\\cellcolor{black}"),
.default(as.character(confirm)))
# turn all lower triangle cells black
tmp = tableData %>%
mutate('be right' = case_when('be right' = TRUE ~ "\\cellcolor{black}"),
confirm = case_when(confirm = TRUE & expression != 'be right' ~ "\\cellcolor{black}"),
.default = as.character(confirm))
tmp
#view(tableData)
tableData
# turn all lower triangle cells black, by each column
tmp = tableData %>% mutate('be right' = case_when('be right' = TRUE ~ "\\cellcolor{black}"))
tmp
tmp = tmp %>%
mutate(confirm = case_when(confirm = TRUE & expression != 'be right' ~ "\\cellcolor{black}"),
.default = as.character(confirm))
tmp
tmp = tmp %>%
mutate(confirm = case_when(confirm = TRUE & expression != 'be right' ~ "\\cellcolor{black}"),
TRUE ~ confirm)
tmp = tmp %>%
mutate(confirm = case_when(confirm = TRUE & expression != 'be right' ~ "\\cellcolor{black}"),
TRUE ~ 'confirm')
#view(tableData)
tableData
# turn all lower triangle cells black, by each column
tmp = tableData %>% mutate('be right' = case_when('be right' = TRUE ~ "\\cellcolor{black}"))
tmp = tmp %>%
# turn all lower triangle cells black, by each column
tmp = tableData %>% mutate('be right' = case_when('be right' = TRUE ~ "\\cellcolor{black}"))
tmp = tmp %>%
mutate(confirm = case_when(confirm = TRUE & expression != 'be right' ~ "\\cellcolor{black}",
TRUE ~ 'confirm'))
tmp
# turn all lower triangle cells black, by each column
tmp = tableData %>% mutate('be right' = case_when('be right' = TRUE ~ "\\cellcolor{black}"))
tmp = tmp %>%
mutate(confirm = case_when(confirm = TRUE & expression != 'be right' ~ "\\cellcolor{black}",
TRUE ~ confirm))
tmp
tmp = tmp %>%
mutate(discover = case_when(discover = TRUE & (expression != 'be right' & expression != "confirm") ~ "\\cellcolor{black}",
TRUE ~ discover))
tmp
tmp = tmp %>%
mutate(confess = case_when(confess = TRUE & (expression != 'be right' & expression != "confirm" & expression != "discover") ~ "\\cellcolor{black}",
TRUE ~ confess))
tmp
tmp = tmp %>%
mutate(know = case_when(know = TRUE & (expression != 'be right' & expression != "confirm"
& expression != "discover" & expression != "confess") ~ "\\cellcolor{black}",
TRUE ~ know))
tmp
tmp = tmp %>%
mutate(`final NRRC` = case_when(`final NRRC` = TRUE & (expression != 'be right' & expression != "confirm"
& expression != "discover" & expression != "confess"
& expression != "know") ~ "\\cellcolor{black}",
TRUE ~ `final NRRC`))
tmp
tableData = tmp
# now create the table to include in the paper
table1 = print(xtable(tableData),
only.contents = T,
include.rownames=FALSE,
include.colnames=FALSE,
floating=FALSE,
hline.after = NULL,
latex.environments=NULL,
booktabs=TRUE,
sanitize.text.function = function(x){x},
comment = F
)
write(table1, "../models/table1.tex")
# set working directory to directory of script
this.dir <- dirname(rstudioapi::getSourceEditorContext()$path)
setwd(this.dir)
# load helper functions
source('../../../helpers.R')
# load cleaned data
d = read_csv("../data/cd.csv")
nrow(d)
length(unique(d$participantID)) #74 participants
# exclude controls
t = d %>%
filter(!(expression == "AI MC" | expression == "NAI MC"))
table(t$expression)
# load the pairwise comparison ----
pairwise = read_csv(file="../models/pairwise1.csv")
pairwise
# select relevant columns for printing
pairwise_reduced = pairwise %>%
select(c(contrast, .value, .lower, .upper))
pairwise_reduced
tableApp1 = print(xtable(pairwise_reduced),
#only.contents = T,
include.rownames=FALSE,
include.colnames=TRUE,
tabular.environment="longtable",
floating=FALSE,
hline.after = NULL,
latex.environments=NULL,
booktabs=TRUE,
sanitize.text.function = function(x){x},
comment = F
)
tableApp1
# write the table, print in latex document in supplement
write(tableApp1, "../models/fullModelOutput.tex")
# select needed columns from the pairwise comparison for the table input
tableInput = pairwise %>%
select(c(contrast, .value, .lower, .upper, first, second)) %>%
select(-c(contrast))
tableInput$second = trimws(tableInput$second)
tableInput
# make tableInput a dataframe
tableInput <- as.data.frame(tableInput)
tableInput
# create separate dataframes for each expression
expressions = unique(as.character(t$expression))
expressions
# create a separate dataframe for each predicate
for (p in expressions) {
assign(paste("data.", p, sep=""), subset(tableInput, tableInput$first == p | tableInput$second == p))
assign(paste("data.", p, sep=""), get(paste("data.", p, sep="")) %>% mutate(expression = c(p)))
write(paste("data.",p,sep=""),file=paste("../models/data.",p,sep=""))
}
# create a tableData dataframe
tableData = data.frame(expression = character(), comparisonExpression = character(), value = numeric(), lower = numeric(), upper = numeric())
tableData
# fill tableData with the relevant information from the individual predicates' dataframes
for (p in expressions) {
for (i in 1:nrow(get(paste("data.",p,sep="")))) {
print(p)
# define some expressions
valueOld = get(paste("data.",p,sep=""))[i,]$.value
lowerOld = get(paste("data.",p,sep=""))[i,]$.lower
upperOld = get(paste("data.",p,sep=""))[i,]$.upper
first = get(paste("data.",p,sep=""))[i,]$first
second = get(paste("data.",p,sep=""))[i,]$second
expression = get(paste("data.",p,sep=""))[i,]$expression
# now fill the dataframe
comparisonExpression = ifelse(expression == first, second, first)
value = ifelse(expression == first, valueOld, -valueOld)
lower = ifelse(expression == first, lowerOld, -upperOld)
upper = ifelse(expression == first, upperOld, -lowerOld)
tableData = tableData %>%
add_row(expression = p, comparisonExpression = comparisonExpression, value = value, lower = lower, upper = upper)
}
}
tableData
exp2 = read.csv("../../exp2/data/cd.csv")
nrow(exp2)
means.exp2 = exp2 %>%
filter(!(expression == "AI MC" | expression == "NAI MC")) %>%
group_by(expression) %>%
summarize(Mean = mean(response))
means.exp2
means.exp2$expression = factor(means.exp2$expression, levels=means.exp2$expression[order(means.exp2$Mean)], ordered=TRUE)
levels(means.exp2$expression)
tableData$expression = factor(tableData$expression, levels=means.exp2$expression[order(means.exp2$Mean)], ordered=TRUE)
tableData
levels(tableData$expression)
# join the tmp dataframe with tableData
tableData = left_join(tableData, means.exp2)
tableData
# also sort the other header row by Exp 2 means
tableData$comparisonExpression = factor(tableData$comparisonExpression, levels=means.exp2$expression[order(means.exp2$Mean)], ordered=TRUE)
# sort by mean (first column) and comparisonExpression (second column)
tableData <- tableData %>% arrange(Mean, comparisonExpression)
tableData
# colorcode the cells (just white = HDI contains 0, red = HDI doesn't contain 0)
tableData$cellColor = ifelse(tableData$lower <= 0 & tableData$upper >= 0, "\\cellcolor{white}",
ifelse(tableData$lower < 0 & tableData$upper < 0 & tableData$value <= -1.5, "\\cellcolor{blue}",
ifelse(tableData$lower < 0 & tableData$upper < 0 & -1.5 < tableData$value & tableData$value <= -0.5, "\\cellcolor{blue}",
ifelse(tableData$lower < 0 & tableData$upper < 0 & -.5 < tableData$value & tableData$value <= 0, "\\cellcolor{blue}",
ifelse(tableData$lower > 0 & tableData$upper > 0 & tableData$value >= 1.5, "\\cellcolor{red}",
ifelse(tableData$lower > 0 & tableData$upper > 0 & 1.5 > tableData$value & tableData$value > 0.5, "\\cellcolor{red}",
ifelse(tableData$lower > 0 & tableData$upper > 0 & .5 > tableData$value & tableData$value >= 0, "\\cellcolor{red}", "error")))))))
tableData$cellColor
# select relevant columns to make the latex table
tableData = tableData %>%
select(c(expression,comparisonExpression,cellColor))
# spread the data wide
tableData = tableData %>%
spread(comparisonExpression,cellColor)
# replace NA with gray cells and expressions with color coded versions
tableData = tableData %>% mutate(across(everything(), ~replace_na(.x, "\\cellcolor{black}")))
# turn all lower triangle cells black, by each column
tmp = tableData %>%
mutate('be right' = case_when('be right' = TRUE ~ "\\cellcolor{black}"))
tmp = tmp %>%
mutate(confirm = case_when(confirm = TRUE & expression != 'be right' ~ "\\cellcolor{black}",
TRUE ~ confirm))
tmp = tmp %>%
mutate(discover = case_when(discover = TRUE & (expression != 'be right' & expression != "confirm") ~ "\\cellcolor{black}",
TRUE ~ discover))
tmp = tmp %>%
mutate(confess = case_when(confess = TRUE & (expression != 'be right' & expression != "confirm" & expression != "discover") ~ "\\cellcolor{black}",
TRUE ~ confess))
tmp = tmp %>%
mutate(know = case_when(know = TRUE & (expression != 'be right' & expression != "confirm"
& expression != "discover" & expression != "confess") ~ "\\cellcolor{black}",
TRUE ~ know))
tmp = tmp %>%
mutate(`final NRRC` = case_when(`final NRRC` = TRUE & (expression != 'be right' & expression != "confirm"
& expression != "discover" & expression != "confess"
& expression != "know") ~ "\\cellcolor{black}",
TRUE ~ `final NRRC`))
tmp
tableData = tmp
# now create the table to include in the paper
table1 = print(xtable(tableData),
only.contents = T,
include.rownames=FALSE,
include.colnames=FALSE,
floating=FALSE,
hline.after = NULL,
latex.environments=NULL,
booktabs=TRUE,
sanitize.text.function = function(x){x},
comment = F
)
write(table1, "../models/table1.tex")
# set working directory to directory of script
this.dir <- dirname(rstudioapi::getSourceEditorContext()$path)
setwd(this.dir)
source('../../../helpers.R')
# load required packages for pre-processing data
library(tidyverse)
theme_set(theme_bw())
# read in the raw data
d = read_csv("../data/combined.csv")
# remove rows with info about instructions and final screens
d <- d %>% filter(!(trial_type %in% c("survey-text", "html-button-response")))
# replace participant_id by random number
length(unique(d$participant_id)) #80
d$participantID <- match(d$participant_id, unique(sort(d$participant_id)))
# how many participants?
length(unique(d$participantID)) #80
# select relevant columns
d = d %>%
select(c(stimulus, response, trial_index, trial_type, participantID))
# unpack demographics info
dg <- d %>%
filter(trial_type == "survey") %>%
select(c(participantID,response))
table(dg$response)
# age
dg$age = as.numeric(gsub("\\D", "", dg$response))
table(dg$age)
mean(dg[dg$age < 100,]$age) # exclude participant who entered 372 from mean calculation
# gender
dg$gender = case_when(grepl("female", dg$response) ~ "female",
grepl("male", dg$response) ~ "male",
grepl("non-binary", dg$response) ~ "non-binary",
TRUE ~ "preferNoToSay")
table(dg$gender)
# language
dg$language = case_when(grepl("language\":\"yes", dg$response) ~ "English",
TRUE ~ "notSpeakerOfEnglish")
table(dg$language)
# American English
dg$amE = case_when(grepl("amE\":\"yes", dg$response) ~ "AmE",
TRUE ~ "notAmE")
table(dg$amE)
# comments
dg$comments = gsub(".*comments", "", dg$response)
table(dg$comments)
# remove response column from demographics data
dg = dg %>%
select(-c(response))
summary(dg)
# add demographics data back to data
d = left_join(d, dg, by = "participantID")
# remove unneeded columns from data
d = d %>%
filter(trial_type != "survey")
d = d %>%
select(-c(trial_index,trial_type))
# make response a numeric column, with values between 0 and 1
summary(d$response)
d$response <- as.numeric(d$response)
d$response <- d$response/100
table(d$response)
# create useful columns
d$expression <- case_when(
grepl("right", d$stimulus) ~ "be right",
grepl("know", d$stimulus) ~ "know",
grepl("discover", d$stimulus) ~ "discover",
grepl("confirm", d$stimulus) ~ "confirm",
grepl("confess", d$stimulus) ~ "confess",
grepl("French course", d$stimulus) ~ "controlGood",
grepl("like apples", d$stimulus) ~ "controlBad",
grepl("found Jack|criticized|manager|forgave|chef|boss|neighbor", d$stimulus) ~ "final NRRC",
grepl("ran away|feels guilty|caught by the police|sweet tooth|apologized|feels upset|driver's license", d$stimulus) ~ "medial NRRC",
TRUE ~ "ERROR"
)
table(d$expression)
# items
d$cc = case_when(grepl("saw the murder", d$stimulus) ~ "saw the murder",
grepl("cheated on his wife", d$stimulus) ~ "cheated on his wife",
grepl("stole the money", d$stimulus) ~ "stole the money",
grepl("ate the last cupcake", d$stimulus) ~ "ate the last cupcake",
grepl("broke the plate", d$stimulus) ~ "broke the plate",
grepl("lost his key", d$stimulus) ~ "lost his key",
grepl("bought a new car", d$stimulus) ~ "bought a new car",
grepl("French course", d$stimulus) ~ "control",
grepl("like apples",d$stimulus) ~ "control",
TRUE ~ "ERROR")
table(d$cc)
# remove stimulus column now that everything has been extracted from it
d = d %>%
select(-c(stimulus))
# check that all predicates and all contents are being presented to participants
table(d$expression)
table(d$cc)
table(d$expression, d$cc)
# participant info
table(d$age) #18-372
length(which(is.na(d$age))) # 0 missing values
# exclude outliers (0, 3330) before calculating mean
mean(d[17 < d$age & d$age < 80,]$age,na.rm=TRUE) #39.13
d %>%
select(gender, participantID) %>%
unique() %>%
group_by(gender) %>%
summarize(count=n())
### exclude non-English speakers and non-American English speakers
# exclude non-English speakers
length(which(is.na(d$language))) #no missing responses
table(d$language) #all the participants are English native speakers
d <- d %>%
filter(language != "notSpeakerOfEnglish") %>%  droplevels()
length(unique(d$participantID)) #80 #0 participants excluded
# exclude non-American English speakers
length(which(is.na(d$amE))) #0 (everybody responded)
table(d$amE)
d <- d %>%
filter(amE != "notAmE") %>%  droplevels()
length(unique(d$participantID)) #78 #2 participants excluded
# exclude participants based on controls
names(d)
table(d$expression)
# plot response by type of control
ggplot(data=d[d$expression == "controlGood",], aes(x=participantID, y=response)) +
geom_point()
ggplot(data=d[d$expression == "controlBad",], aes(x=participantID, y=response)) +
geom_point()
# good control
goodControl = d %>%
filter(expression == "controlGood")
nrow(goodControl) #78 participants
# identify participants whose response to the good control is more than 2sd lower than the mean
mean(goodControl$response) # .87
mean(goodControl$response) - 2*sd(goodControl$response) # 0.560572
outliers.good = goodControl[goodControl$response < (mean(goodControl$response) - 2*sd(goodControl$response)),]
nrow(outliers.good)
# bad control
badControl = d %>%
filter(expression == "controlBad")
nrow(badControl) #78 participants
# identify participants whose response to the bad control is more than 2sd higher than the mean
mean(badControl$response) # .051
mean(badControl$response) + 2*sd(badControl$response) # 0.356365
outliers.bad = badControl[badControl$response > (mean(badControl$response) + 2*sd(badControl$response)),]
nrow(outliers.bad)
# remove the participants who got either one of the controls wrong
d = d %>%
filter(!(participantID %in% outliers.good$participantID)) %>%
filter(!(participantID %in% outliers.bad$participantID))
length(unique(d$participantID)) # 71 (so 7 participants excluded)
# age and gender of remaining participants
table(d$age) #18-372
length(which(is.na(d$age))) # 0 missing values
# exclude outliers (372) before calculating mean
mean(d[d$age < 100,]$age,na.rm=TRUE) #39.51
d %>%
select(gender, participantID) %>%
unique() %>%
group_by(gender) %>%
summarize(count=n())
nrow(d)
# code response such that 1 = not-at-issue and 0 = at-issue
d$response = 1-d$response
table(d$response)
means = d %>%
filter(!(expression == "AI MC" | expression == "NAI MC")) %>%
group_by(expression) %>%
summarize(Mean = mean(response))
means
means = d %>%
filter(!(expression == "controlBad" | expression == "controlGood")) %>%
group_by(expression) %>%
summarize(Mean = mean(response))
means
write_csv(d, file="../data/cd.csv")
# set working directory to directory of script
this.dir <- dirname(rstudioapi::getSourceEditorContext()$path)
setwd(this.dir)
# load required packages
library(tidyverse)
# color-blind-friendly palette
cbPalette <- c("#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")
theme_set(theme_bw())
# load cleaned data
d = read_csv("../data/cd.csv")
length(unique(d$participantID)) #71 participants
# exclude controls
t = d %>%
filter(!(expression == "controlBad" | expression == "controlGood"))
table(t$expression)
# mean rating by expression
means = t %>%
group_by(expression) %>%
summarize(Mean = mean(response), CILow = ci.low(response), CIHigh = ci.high(response)) %>%
mutate(YMin = Mean - CILow, YMax = Mean + CIHigh, expression = fct_reorder(as.factor(expression),Mean))
means
# range
min(means$Mean)
max(means$Mean)
max(means$Mean) - min(means$Mean)
# plot
ggplot(data=means, aes(x=expression, y=Mean)) +
geom_violin(data=d, aes(x=expression, y=response), scale="width", fill = "grey", linewidth=0, alpha=.4) +
geom_point(size=2.5,color="black") +
geom_errorbar(aes(ymin=YMin,ymax=YMax),width=0.1,color="black") +
scale_y_continuous(limits = c(0,1),breaks = c(0,0.2,0.4,0.6,0.8,1.0)) +
theme(text = element_text(size=12), axis.text.x = element_text(size = 12, angle = 45, hjust = 1)) +
theme(legend.position="none") +
theme(panel.grid.major.x = element_blank()) +
ylab("Mean naturalness rating \n Direct dissent diagnostic") +
xlab("Expression")
# plot
ggplot(data=means, aes(x=expression, y=Mean)) +
geom_violin(data=t, aes(x=expression, y=response), scale="width", fill = "grey", linewidth=0, alpha=.4) +
geom_point(size=2.5,color="black") +
geom_errorbar(aes(ymin=YMin,ymax=YMax),width=0.1,color="black") +
scale_y_continuous(limits = c(0,1),breaks = c(0,0.2,0.4,0.6,0.8,1.0)) +
theme(text = element_text(size=12), axis.text.x = element_text(size = 12, angle = 45, hjust = 1)) +
theme(legend.position="none") +
theme(panel.grid.major.x = element_blank()) +
ylab("Mean naturalness rating \n (higher rating = more not-at-issue)") +
xlab("Expression")
ggsave("../graphs/mean-ratings.pdf",height=4.5,width=7)
# load required packages
library(tidyverse)
library(tidybayes)
library(brms)
library(emmeans)
library(lme4)
library(lmerTest)
library(xtable)
# set working directory to directory of script
this.dir <- dirname(rstudioapi::getSourceEditorContext()$path)
setwd(this.dir)
# load helper functions
source('../../../helpers.R')
# load cleaned data
d = read_csv("../data/cd.csv")
nrow(d)
length(unique(d$participantID)) #71 participants
# exclude controls
t = d %>%
filter(!(expression == "controlBad" | expression == "controlGood"))
table(t$expression)
# set reference level
t = t %>%
mutate(expression = fct_relevel(expression, "be right"))
levels(t$expression)
# response distribution before transformation
summary(t$response)
# first, because response assumes values of 0 and 1, which beta regression cannot handle, transform: (Smithson & Verkuilen 2006)
# y_new = (y_old * (n−1) + 0.5) / n (where n is the sample size)
# note: first rescaling of y'=(y-a)/(b-a) not necessary because highest and lowest value are 0 and 1 already
t$betaresponse = (t$response*(nrow(t)-1) + .5)/nrow(t)
summary(t$betaresponse)
# fit the model
prior = get_prior(betaresponse ~ expression + (1|participantID) + (1|cc),family = Beta(),data=t)
prior
betamodel = bf(betaresponse ~ expression + (1|participantID) + (1|cc),
phi ~ expression + (1|participantID) + (1|cc), # beta distribution's precision
family = Beta())
m.b = brm(formula = betamodel,
family=Beta(),
data=t,
cores = 3, iter = 4000, warmup = 700,
control = list(adapt_delta = .99,max_treedepth=17))
